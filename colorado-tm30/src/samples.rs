/*!

# IES TM30 Sample Illuminants

A collection of spectral emissivity data for sample lamps, standard reference illuminant spectra,
and spectral distributions from mathematical models, as used by the IES TM30 standardization committee for testing
their color fidelity and color preference metrics.
The intention of this dataset is to be used for general color science research, and the spectral distributions of 
the commcercially available lamps have to be considered as just examples, and are by no means representative for 
the typical or average performance of these lamps.

The collection is described in [Collections Overview](#collections-overview) below, using the [categories](#categories)
as used by the IES TM30 committee.
The data is given on the wavelength range from 380 to 780nm, with steps of 1nm.

The spectral distribution data can be used in various ways:

## Use as an illuminant in colorimetric calculations

The data can be used as illuminants through the `TM30Illuminant` type, which takes a `const` identifier as type
argument. 

## Use for generic spectral calculations

The following types can be use for generic color science work

- All the sample spectral data is available through the `TM30SampleSpectra` type,
by using its `default()` constructor. This type implements the `SpectralDistribution` trait,
which makes the spectral data available through its `spd` method. It also implements the `From` 
trait for `CieXYZ`, and can therefor be used in all the models which accept generic CieXYZ
arguments.
And using the spectral data itself, in form of a `nalgebra::Matrix` type, the data can be directly
analyzed.

- For colorimetric analysis on sample data groups, `CieXYZ` data can be generated by selection of
`EmissionType`, or `EmissionType` and `ModelType`, by using the `From<EmissionType>` and  `From<(EmissionType,ModelType)>` 
implementations. The corresponding spectral keys can be obtained using the equivaluent `From` implementation
for `Vec<&str>`.

## Categories




# Collections Overview

## Fluorescent Broadband 
`EmissionType::FluorescentBroadBand`

### CIE Standard Illuminants
`CieF1`, `CieF2`, `CieF3`, `CieF4`, `CieF5`, `CieF6`, `CieF7`, `CieF8`, `CieF9`

### Measured Commercial
`F32T8v930`
`F32T8v950`
`F34T12CwRsEw`
`F34T12LwRsEw`
`F34T12WwRsEw`
`F40T12C50a`
`F40T12C50b`
`F40T12C75a`
`F40T12C75b`
`F40T12CWXa`
`F40T12CWXb`
`F40T12DXa`
`F40T12DXb`
`F40T12DXTPa`
`F40T12DXTPb`
`F40T12N1`
`F40T12N2`


## Fluorescent Narrowband
`EmissionType::FluorescentNarrowBand`

### CIE Standard Illuminants
`CieF10`
`CieF11`
`CieF12`


### Measured Commercial
`F32T8v730`
`F32T8v735`
`F32T8v741`
`F32T8v750`
`F32T8v830a`
`F32T8v830b`
`F32T8v830c`
`F32T8v835a`
`F32T8v835b`
`F32T8v835c`
`F32T8v841a`
`F32T8v841b`
`F32T8v841c`
`F32T8v850a`
`F32T8v850b`
`F32T8v850c`
`F32T8v865a`
`F32T8v865b`
`F40T12v30U`
`F40T12v35U`
`F40T12v41U`
`F40T12v50U`


### Modifield Fluorescent Lamps
`ModTriPhosphorTG0`
`ModTriPhosphorTG6`
`ModTriPhosphorTG10`
`ModTriPhosphorTP5`



## High Intensity Discharge Lamps 
`EmissionType::HighIntensityDischarge`

All the spectral distributions in this category are measured spectral distribution from commercially available lamps.

`C100S54HPSStd1`
`C100S54HPSStd2`
`C100S54CHPSDeLuxe1`
`C100S54CHPSDeLuxe2`
`SDWT100WLVSuperHPS1`
`SDWT100WLVSuperHPS2`
`CDM830a`
`CDM830b`
`CDM830c`
`CDM940a`
`CDM940b`
`MH100W`
`MHC100Ump3K1`
`MHC100Ump4K1`
`MHC100Ump3K2`
`MHC100Ump4K2`
`H38HT100Mercury1`
`H38HT100Mercury2`
`H38JA100DxMercury1`
`H38JA100DxMercury2`


## Incandescent Or Filament Lamps 
`EmissionType::IncandescentOrFilament`

All the spectral distributions in this category are measured examples of commercially available lamps:`

- 3 Halogen lamps (`Halogen1`, `Halogen2`, and `Halogen3`)
- 3 Halogen MR16 spot lamps (`HalogenMR16a`, `HalogenMR16b`, `HalogenMR16c`)
- A standard 60W A 19 incandescent lamp (`Inc60WA19`)
- A 75W A19 Halogena lamp, an A19 shaped bulb with a mains voltage Halogen lamp as source inside (`Inc75WA19HalogenA`)
- A 75W A19 Incandescent lamp, with its light filtered by Neodymium coating on the insize of the bulb (`Inc75WA19Neodymium`)
- Another 75W A19 Incandescent lamp example, in this case one of the so-called "Rough House" variety,
	which has a stronger filament design  (`Inc75WA19RoughHouse`)
- And a 75W A19 "Softer White" sample (`Inc75WA19SofterWhite`)
- Krypton Incandescent (`KryptonInc`)
- Neodymium Incandescent (`NeodymiumInc`)
- and last, a "Filtered Halogen" example (`FilteredHalogen`)

## LED Hybrid Lamps 
`EmissionType::LedHybrid`

### Blue Pump
`LedHybridBluePump1` - `LedHybridBluePump13`


### Violet Pump
`LedHybridVioletPump1`
`LedHybridVioletPump2`

## Mixed distributions for RGB, and RGBA LED lamps 
`EmissionType::LedMixed`

### RGB
`Rgb445n500n640nE`
`Rgb445n500n640nM`
`Rgb445n515n640`
`Rgb445n520n640`
`Rgb450n525n625n3K`
`Rgb450n525n625n4K`
`Rgb450n530n645n`
`Rgb455n530n615n`
`Rgb455n534n616n`
`Rgb455n547n623n`
`Rgb457n540n605n`
`Rgb460n525n625n`
`Rgb460n540n620n`
`Rgb464n538n613n`
`Rgb464n546n620n`
`Rgb464n562n626n`
`Rgb465n525n630n`
`Rgb465n530n620n`
`Rgb465n535n590n`
`Rgb465n546n614n`
`Rgb466n538n603n`
`Rgb467n548n616n`
`Rgb470n525n630n`
`Rgb470n530n635n`
`Rgb472n550n603n`
`Rgb473n545n616n`
`Rgb474n545n616nTG6`
`Rgb474n545n616nTG10`
`Rgb474n545n616nTG0`
`Rgb474n545n616nTP6`
`Rgb475n515n630n`
`Rgb475n545n615n`


### RGBA
`Rgba445n495n555n615nE`
`Rgba445n495n555n615nM`
`Rgba445n505n590n640n`
`Rgba445n505n595n640n`
`Rgba445n520n595n640n`
`Rgba447n512n573n627n`
`Rgba450n525n580n625n`
`Rgba450n525n600n650n`
`Rgba455n530n590n635n3K`
`Rgba455n530n590n635n3Ka`
`Rgba455n530n590n635n3Kb`
`Rgba455n530n590n635n3Kc`
`Rgba455n530n590n635n3Kd`
`Rgba455n530n590n635n3Ke`
`Rgba455n530n590n635n3Kf`
`Rgba455n530n590n635n3Kg`
`Rgba455n530n590n635n3Kh`
`Rgba455n530n590n635n3Ki`
`Rgba455n530n590n635n4K`
`Rgba455n530n590n635n4Ka`
`Rgba455n530n590n635n4Kb`
`Rgba455n530n590n635n4Kc`
`Rgba455n530n590n635n4Kd`
`Rgba455n530n590n635n4Ke`
`Rgba455n530n590n635n4Kf`
`Rgba455n530n590n635n4Kg`
`Rgba455n530n590n635n4Kh`
`Rgba455n530n590n635n4Ki`
`Rgba460n530n575n625n`
`Rgba461n526n576n624n`
`Rgba470n520n595n635n27K`
`Rgba470n520n595n635n65K`

## LDRD 
`Ldrd1`
`Ldrd2`
`Ldrd3`
`Ldrd4`
`Ldrd5`
`Ldrd6`
`Ldrd7`
`Ldrd8`
`Ldrd9`
`Ldrd10`
`Ldrd11`
`Ldrd12`
`Ldrd13`
`Ldrd14`
`Ldrd15`
`Ldrd16`
`Ldrd17`
`Ldrd18`
`Ldrd19`
`Ldrd20`
`Ldrd21`
`Ldrd22`
`Ldrd23`
`Ldrd24`
`Ldrd25`
`Ldrd26`


## LED Phosphor Lamps 
`EmissionType::LedPhosphor`

### Blue Pump
`LedPhBluePump01` - `LedPhBluePump125`


### Violet Pump
`LedPhVioletPump1`
`LedPhVioletPump2`
`LedPhVioletPump3`
`LedPhVioletPump4`



## Mathematical Spectral Distributions 
`EmissionType::Mathematical`

### CIE D-Series
`CieD5000K`
`CieD5500K`
`CieD6000K`
`CieD6500K`
`CieD7000K`
`CieD7500K`
`CieD8000K`


### Mixed reference
`MixedReference5000K`

### Planckian Sources
`Planckian2000K`
`Planckian2500K`
`Planckian2700K`
`Planckian3000K`
`Planckian3500K`
`Planckian4000K`
`Planckian4500K`
`Planckian4999K`


## Other Spectral Distributions
`EmissionType::Other`


### Equal Energy spectrum
`EqualEnergy`


### Ideal Prime color
`IdealPrimeColor`


## Plasma lamps
`Plasma`

## Triband Gaussian model
`TriBandGaussian1`
`TriBandGaussian2`


*/


mod data;
pub use data::*;

use std::collections::HashMap;
use colorado::illuminants::Illuminant;
use colorado::observers::StandardObserver;
use colorado::models::{CieXYZ, XYZValues};
use colorado::{DataSpectrumFromSlice, Domain, NM, SpectralDistribution, WavelengthStep};
use nalgebra::{SVectorSlice, Matrix3xX, SMatrixSlice};
use self::data::{TM30_ILLUMINANTS_DATA, TM30_CIE1931, N, M};

/**
Use TM30 Sample Spectrum as illuminant.

Illuminants are used in this library to represent the, typically 'white', illumination
used to illuminate objects such as swatches, or backlight LCD pixels.
Each illuminant in the colorado library has its own type, and is constructed by its
`Default::default` method only.

The use the spectral distributions in the TM30 library as illuminant in the color models
use the `TM30Illuminant::<const K:usize>` type, where `K` can be specified as one of the 
TM30 library constants.

For example, to get the CIE F1 illuminant from this library, use the `CIE_F1` constant:
```
	use colorado_tm30::samples::{TM30Illuminant, CieF1};

	use colorado::models::{CieYxy, YxyValues};
	let xy: CieYxy = CieF1::default().into();
	let YxyValues{l:_, x, y} = xy.into_iter().next().unwrap();

	use approx::assert_abs_diff_eq;
	assert_abs_diff_eq!(x,0.313100, epsilon=1E-6);
	assert_abs_diff_eq!(y,0.337279, epsilon=1E-6);

```
*/
#[derive(Default)]
pub struct TM30Illuminant<const K:usize>;

impl<const K:usize> SpectralDistribution for TM30Illuminant<K> {
    type MatrixType = SVectorSlice<'static, f64, N>;
    type StepType = WavelengthStep;

    fn spd(&self) -> (Domain<Self::StepType>, Self::MatrixType) {
        (Domain::new(380, 780, NM), Self::MatrixType::from_slice(&TM30_ILLUMINANTS_DATA[(K-1)*N..K*N]))
    }

    fn shape(&self) -> (usize, usize) {
		(N,1)
    }
}

impl<const K:usize> Illuminant for TM30Illuminant<K>{}

impl<C: StandardObserver, const K: usize> From<TM30Illuminant<K>> for CieXYZ<C> {
	fn from(_: TM30Illuminant<K>) -> Self {
		TM30Illuminant::<K>::default().xyz()	
	}
}

#[test]
fn test_tm30_ill(){
	use colorado::models::{CieYxy, YxyValues};
	use approx::assert_abs_diff_eq;
	use crate::samples::CieF1;

	let ill = CieF1::default();
	let xy: CieYxy = ill.into();
	let YxyValues{l:_, x, y} = xy.into_iter().next().unwrap();

	assert_abs_diff_eq!(x,0.313100, epsilon=1E-6);
	assert_abs_diff_eq!(y,0.337279, epsilon=1E-6);
}

pub struct TM30SampleSpectra(
	Domain<<Self as SpectralDistribution>::StepType>,
	<Self as SpectralDistribution>::MatrixType
);

impl Default for TM30SampleSpectra {
	fn default() -> Self {
        Self (
			Domain::new(380, 780, NM), 
			<Self as SpectralDistribution>::MatrixType::from_slice(&TM30_ILLUMINANTS_DATA))
	}
}

impl SpectralDistribution for TM30SampleSpectra {
    type MatrixType = SMatrixSlice<'static, f64, N, M>;
    type StepType = WavelengthStep;

    fn spd(&self) -> (Domain<Self::StepType>, Self::MatrixType) {
		(self.0.clone(), self.1)
    }

    fn shape(&self) -> (usize, usize) {
		(N,M)
    }
}


impl<C: StandardObserver> From<TM30SampleSpectra> for CieXYZ<C> {
	fn from(ill: TM30SampleSpectra) -> Self {
		ill.xyz()	
	}
}

#[test]
fn test_tm30_sample_spectra(){
	use colorado::models::CieYxy;
	let ill = TM30SampleSpectra::default();
	let xy: CieYxy = ill.into();
	println!{"{}", xy.data.transpose()};
}



#[derive(Clone,  PartialEq,  Eq)]
pub enum EmissionType {
	FluorescentBroadband = 0,
	FluorescentNarrowband = 1,
	HighIntensityDischarge = 3,
	IncandescentOrFilament = 4,
	LedHybrid = 5,
	LedMixed = 6,
	LedPhosphor = 7,
	Mathematical = 8,
	Other = 9,
}

pub enum ModelType {
	Model = 0,
	Commercial = 1,
	Experimental = 2,
	Theoretical = 3,
}

pub fn tm30_cie1931_xy() -> HashMap<&'static str, [f64;2]> {
	TM30_CIE1931.iter().map(|(key,_,_,x,y)|(*key,[*x,*y])).collect()
}


impl From<EmissionType> for Vec<&str> {
	fn from(et: EmissionType) -> Self {
		let e = et as u32;
		let mut v: Vec<&str> = Vec::with_capacity(M);
		for (k,j,..) in TM30_CIE1931.iter() {
			if e==*j {
				v.push(k);
			}
		}
		v
	}

}

impl<C: StandardObserver> From<EmissionType> for CieXYZ<C> {
	fn from(et: EmissionType) -> Self {
		let e = et as u32;
		let mut v: Vec<f64> = Vec::with_capacity(3*M);
		for (i,(_,j,..)) in TM30_CIE1931.iter().enumerate(){
			if e==*j {
				let sd = DataSpectrumFromSlice::new(Domain::new(380, 780, NM), &TM30_ILLUMINANTS_DATA[i*N..(i+1)*N]);
				let XYZValues{x, y, z} = sd.xyz::<C>().into_iter().next().unwrap();
				v.push(x);
				v.push(y);
				v.push(z);
			}
		}
		Self::new(Matrix3xX::from_vec(v))
	}
}




#[test]
fn test_from_emission_type(){
	use colorado::models::{CieYxy, YxyValues};
	use approx::assert_abs_diff_eq;

	for emission_type in [
			EmissionType::FluorescentNarrowband,
			EmissionType::FluorescentBroadband,
			EmissionType::HighIntensityDischarge,
			EmissionType::IncandescentOrFilament,
			EmissionType::LedHybrid,
			EmissionType::LedMixed,
			EmissionType::LedPhosphor,
			EmissionType::Mathematical,
			EmissionType::Other,
		]
		{
		let xyz: CieYxy = emission_type.clone().into();
		let keys: Vec<&str> = emission_type.into();
		let w = tm30_cie1931_xy();
		for (YxyValues {l: _, x,y}, k) in xyz.into_iter().zip(keys.into_iter()) {
			let [xw,yw] = w[k];
			assert_abs_diff_eq!(x,xw,epsilon=5E-7);
			assert_abs_diff_eq!(y,yw,epsilon=5E-7);
			println!("{} {} {} {} {}" , k, x, y, xw, yw);
		}

	}
}